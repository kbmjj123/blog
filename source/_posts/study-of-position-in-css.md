---
title: 定位属性查漏补缺
description: 定位属性查漏补缺
author: Zhenggl
date: 2022-04-28 09:09:29
categories:
    - [css, position]
tags:
    - css
    - position
cover_picture: 定位属性查漏补缺封面.jpeg
---

### 前言
> 定位属性`position`，我想这个属性应该是绝大多数前端基本都滚瓜烂熟的了吧，什么"父相子绝"的快速记住其使用方法；
> 🤔 但是这里如果采用了非强制限定定位元素的尺寸、位置，定位元素可以被允许按照其内容来"安排"自己的话，是否就是可以实现到灵活性更高的布局以及内容的自适应的展示呢？

### 基本概念

| positions属性 | 描述 |
|---|---|
| 取值 | static / relative / sticky / absolute / fixed |
| 初始值 | static |
| 适用于 | 所有元素 |
| 继承性 | 否 |

✨ `position`的各个属性描述如下：
1. static: 正常生成元素框，块级元素生成矩形框，位于文档流中，行内元素生成一个/多个框，跟随父元素流动；
2. relative: 元素框偏移一定的距离，元素的形状以及所占据的空间不变；
3. absolute: 元素框完全从文档流中移除，相对**容纳块**定位；
4. fixed: 相对于视区进行`absolute`；
5. sticky: 元素以开始留在常规的文档流中，达到触发粘滞的条件是，从常规的文档流中移除，但原本所占据的空间仍然保留，在此中情况下，相当于相对于容纳块`absolute`

#### 不一样的容纳块
> 对于定位元素而言，容纳块完全取决于定位类型；
> ✨ 对非根元素而言，如果position属性的值是`relative/static`，其容纳块由最近的块级、单元格或行内块级祖辈元素框的content边界划定；
> ✨ 而如果position属性的值是`absolute`，那么其容纳块由最近的**非static**的祖先元素组成。
>
> ⚠️ 定位元素可能会位于容纳块的外部，因为我们可以使用偏移属性，将其偏移到容纳块的外部！！！

#### 偏移属性(top、right、bottom、left)
> 👆中使用的定位方式可以指定每种定位方式的偏移量，这4中属性叫做*偏移属性*，指定距容纳块最近的变的偏移量;
> 以设置了定位属性的元素框来说，让自身相对于容纳块进行偏移量的调整，来实现布局的调整；

| 偏移属性 | 描述 |
|---|---|
| 取值 | length/percentage/auto |
| 初始值 | auto |
| 适用于 | 定位元素 |
| 继承性 | 否 |
| 百分数计算规则 | `top/bottom`相对于容纳块的高度来计算，`left/right`相对于容纳块的宽度来计算 |

![定位属性的元素坐标轴](定位属性的元素坐标轴.jpg)

当出现了负数的数值时，也就是代表着从👆的坐标轴上从容纳块中突出来，如下所示：

![从容纳块中突出的定位元素框](从容纳块中突出的定位元素框.jpg)

#### 宽度与高度(width、height)
> 有时候，将元素确定定位的位置之后，可能还需要声明元素的宽度以及高度，或者想限定元素的高度以及宽度，
> 而有时候，元素的宽度以及高度则会有用户代理自行自动计算。

✨ 有时，如果我们使用了定位属性来定位元素的同时，一般利用两个轴方向上的一个属性即可确定元素的位置，比如left+top、left+bottom、right+top、right+bottom 4⃣️种组合
方式，可以确定一个元素的位置，如果我们直接是4个属性一起设置，还可以通过4个属性以及容纳块的信息，来确定当前定位元素框的一个宽度以及高度(因为width与height的默认值是auto)，
⚠️但是如果定位元素框添加了padding、border、margin的时候，由于默认的`box-sizing: padding-box`，在设置了width以及height了之后，将导致它还会继续往外撑开，这是可以是
采用`box-sizing: border-box`的方式来保证元素的width以及height的一个计算规则！！！


#### 溢出(overflow)
> 如果🈶️个固定尺寸的元素，内容放不下，这种情况下使用overflow属性来处理

| overflow属性 | 描述 |
|---|---|
| 取值 | visible/hidden/scroll/auto |
| 适用于 | 所有元素 |
| 初始值 | visible |
| 继承性 | 否 |

📖 默认visible的意思是，超出元素框的内容是可见的，👇来对比下不同的取值所对应的效果：
![overflow不同属性对比](overflow不同属性对比.png)

从上面我们可以看出平时在使用滚动条的时候，多考虑使用auto，因为auto会根据内容进行滚动条的控制，👆的auto控制了只在y轴方向上出现滚动条

#### 可见性(visibility)
> 控制整个元素的可见性

| visibility属性 | 描述 |
|---|---|
| 取值 | visible/hidden/collapse |
| 初始值 | visible |
| 适用于 | 所有元素 |
| 继承性 | 否 |

⚠️ `visibility:hidden(这里简称前者)`与`display:none(这里简称后者)`的区别: 前者隐藏后依然占据空间，而后者不占据空间！

#### Z轴上的位置(z-index)
> 如果两个元素框在2D空间上发生了重叠的话，那么哪个应该是在上层呢？我们可以利用`z-index`来控制元素处于上层
> ✨ 如果两个定位元素发生了重叠，那么后编写在html节点中的，将会覆盖上一个定位元素：
> ![one先定义](one先定义.png)
> ![two先定义](two先定义.png)
> ![使用了z-index](使用了z-index.png)
> 上面第3⃣️种情况下，使用了z-index的定位元素，将会覆盖在未使用该属性，或者比当前元素使用的z-index值要小！！！

🤔 如果是嵌套使用的话，其内容又会是怎样的一个效果呢？？
![使用了z-index](使用了z-index.png)

🤔 如果上面中的定位元素又包含了子元素，自元素的z轴层级关系，将会按照父容器的层级关系来摆放内容！！
![下层孩子内容](下层孩子内容.png)
👆这个时候的孩子被挡住了，那如果我们想把孩子元素控制为不被挡住的话，可以将孩子元素定义为定位属性，然后将其z-index值设置为大于0的数字，告诉其层级要比one父容器要高
![不会提升的z-index](不会提升的z-index.png)

🪐 由👆我们可以得知日常在使用`z-index`的时候有这样子的一个规则：
1. 同一个容纳块中有两个或者两个以上的定位元素，为灵活控制元素的z轴，推荐将其中各个元素的`z-index`属性给配置好，按照实际情况进行数字的配置；
2. 如果设置了`z-index`属性的元素又包含🈶️其他的`z-index`子元素，则需要将其设置为在👆第一点的基础上进行与容纳块自身的其他元素设置

### 绝对定位(absolute)


#### 容纳块所导致的区别

#### 利用位置+尺寸来定义定位元素

##### 非置换元素的位置与尺寸

##### 置换元素的位置与尺寸

#### 自定确定边界

### 固定定位(fixed)

### 相对定位(relative)

### 粘滞定位(sticky)
